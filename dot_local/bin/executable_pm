#!/usr/bin/env node

const fs = require('fs').promises;
const path = require('path');
const { execSync, spawn } = require('child_process');
const os = require('os');

class ProjectManager {
  constructor() {
    this.projectsDir = process.env.PROJECTS;
    if (!this.projectsDir) {
      console.error('Error: $PROJECTS environment variable is not set');
      process.exit(1);
    }
  }

  // Normalize repo name to handle case sensitivity on macOS
  normalizeRepoName(repoName) {
    const parts = repoName.split('/');
    if (parts.length !== 2) {
      throw new Error('Repository name must be in format "owner/repo"');
    }
    return `${parts[0].toLowerCase()}/${parts[1].toLowerCase()}`;
  }

  // Get the expected directory path for a repo
  getRepoPath(repoName) {
    const normalized = this.normalizeRepoName(repoName);
    return path.join(this.projectsDir, 'github.com', normalized);
  }

  // Check if directory exists (case-insensitive search on macOS)
  async findExistingRepo(repoName) {
    const expectedPath = this.getRepoPath(repoName);
    const parentDir = path.dirname(expectedPath);
    const expectedDirName = path.basename(expectedPath);

    try {
      const entries = await fs.readdir(parentDir);
      const match = entries.find(entry =>
        entry.toLowerCase() === expectedDirName.toLowerCase()
      );

      if (match) {
        return path.join(parentDir, match);
      }
    } catch (error) {
      // Parent directory doesn't exist
      return null;
    }

    return null;
  }

  // Clone repository using git
  async cloneRepo(repoName) {
    const repoPath = this.getRepoPath(repoName);
    const repoUrl = `https://github.com/${repoName}.git`;

    console.log(`Cloning ${repoName}...`);

    // Ensure parent directory exists
    await fs.mkdir(path.dirname(repoPath), { recursive: true });

    try {
      execSync(`git clone "${repoUrl}" "${repoPath}"`, {
        stdio: 'inherit',
        cwd: this.projectsDir
      });
      console.log(`✓ Successfully cloned ${repoName}`);
      
      // Invalidate completion cache so new project appears in tab completions
      this.invalidateCompletionCache();
      
      return repoPath;
    } catch (error) {
      console.error(`✗ Failed to clone ${repoName}:`, error.message);
      throw error;
    }
  }

  // Generate shell command to change directory
  generateCdCommand(targetPath) {
    const shell = process.env.SHELL || '/bin/bash';

    if (shell.includes('zsh')) {
      return `cd "${targetPath}"`;
    } else if (shell.includes('bash')) {
      return `cd "${targetPath}"`;
    } else if (shell.includes('fish')) {
      return `cd "${targetPath}"`;
    }

    return `cd "${targetPath}"`;
  }

  // Main function to get or clone a project
  async getProject(repoName) {
    try {
      // First, check if repo already exists
      let repoPath = await this.findExistingRepo(repoName);

      if (repoPath) {
        console.log(`✓ Found existing repository at: ${repoPath}`);
      } else {
        // Clone the repository
        repoPath = await this.cloneRepo(repoName);
      }

      // Print the path for shell integration
      console.log(repoPath);
      return repoPath;

    } catch (error) {
      console.error('Error:', error.message);
      process.exit(1);
    }
  }

  // List all projects
  async listProjects() {
    const githubDir = path.join(this.projectsDir, 'github.com');

    try {
      const owners = await fs.readdir(githubDir);
      const projects = [];

      for (const owner of owners) {
        const ownerPath = path.join(githubDir, owner);
        const stat = await fs.stat(ownerPath);

        if (stat.isDirectory()) {
          try {
            const repos = await fs.readdir(ownerPath);
            for (const repo of repos) {
              const repoPath = path.join(ownerPath, repo);
              const repoStat = await fs.stat(repoPath);
              if (repoStat.isDirectory()) {
                projects.push({
                  name: `${owner}/${repo}`,
                  path: repoPath
                });
              }
            }
          } catch (error) {
            // Skip if can't read directory
          }
        }
      }

      return projects;
    } catch (error) {
      console.error('Error listing projects:', error.message);
      return [];
    }
  }

  // Update all projects
  async updateProjects() {
    const projects = await this.listProjects();

    console.log(`Updating ${projects.length} projects...`);

    for (const project of projects) {
      try {
        console.log(`Updating ${project.name}...`);
        execSync('git pull --ff-only', {
          cwd: project.path,
          stdio: 'pipe'
        });
        console.log(`✓ ${project.name} updated`);
      } catch (error) {
        console.log(`✗ ${project.name} failed to update`);
      }
    }
  }

  // Invalidate shell completion cache
  // Called after operations that change the project list (clone, etc.)
  invalidateCompletionCache() {
    const cacheDir = path.join(os.homedir(), '.local/share/pm');
    const cacheFile = path.join(cacheDir, 'projects.cache');
    
    try {
      fs.unlinkSync(cacheFile);
    } catch (error) {
      // Cache didn't exist or couldn't be deleted, not a critical error
    }
  }

  // Debug cache status for troubleshooting completion issues
  async debugCompletion() {
    const cacheDir = path.join(os.homedir(), '.local/share/pm');
    const cacheFile = path.join(cacheDir, 'projects.cache');
    
    console.log('\nPM Completion Cache Status:');
    console.log(`  Cache file: ${cacheFile}`);
    
    try {
      const stats = await fs.stat(cacheFile);
      const content = await fs.readFile(cacheFile, 'utf8');
      const lines = content.split('\n');
      
      // Parse cache contents
      const cacheTime = lines.find(l => l.startsWith('CACHE_TIME='))?.split('=')[1];
      const owners = lines.find(l => l.startsWith('OWNERS='))?.split('=')[1];
      const repos = lines.find(l => l.startsWith('REPOS='))?.split('=')[1];
      
      // Calculate cache age
      const now = Math.floor(Date.now() / 1000);
      const age = cacheTime ? now - parseInt(cacheTime) : 0;
      const ageMinutes = Math.floor(age / 60);
      const ageSeconds = age % 60;
      const stale = age > 1800; // 30 minutes
      
      console.log(`  Exists: yes`);
      console.log(`  Age: ${ageMinutes} minutes ${ageSeconds} seconds`);
      console.log(`  Stale: ${stale ? 'yes' : 'no'} (TTL: 30 minutes)`);
      console.log(`  Size: ${(stats.size / 1024).toFixed(1)} KB`);
      
      // Count owners and repos
      const ownerCount = owners ? owners.split('|').filter(o => o.length > 0).length : 0;
      const repoCount = repos ? repos.split('|').filter(r => r.length > 0).length : 0;
      
      console.log(`  Owners: ${ownerCount}`);
      console.log(`  Repos: ${repoCount}`);
      
      if (cacheTime) {
        const date = new Date(parseInt(cacheTime) * 1000);
        console.log(`  Last refresh: ${date.toLocaleString()}`);
      }
      
      console.log('\nCache content preview:');
      if (ownerCount > 0) {
        const ownerList = owners.split('|').slice(0, 5);
        console.log(`  First ${Math.min(5, ownerCount)} owners: ${ownerList.join(', ')}`);
        if (ownerCount > 5) console.log(`  ... and ${ownerCount - 5} more`);
      }
      if (repoCount > 0) {
        const repoList = repos.split('|').slice(0, 5);
        console.log(`  First ${Math.min(5, repoCount)} repos: ${repoList.join(', ')}`);
        if (repoCount > 5) console.log(`  ... and ${repoCount - 5} more`);
      }
      
    } catch (error) {
      console.log(`  Exists: no`);
      console.log(`  Status: Cache will be built on next tab completion`);
      console.log(`  Reason: ${error.message}`);
    }
  }

  // Search for projects matching a pattern (for completion)
  async searchProjects(pattern) {
    const projects = await this.listProjects();
    const matches = projects.filter(project =>
      project.name.toLowerCase().includes(pattern.toLowerCase())
    );

    return matches.map(p => p.name).sort();
  }

  // Get completion suggestions
  async getCompletions(partial) {
    if (!partial) {
      return ['help', 'list', 'update', 'clean'];
    }

    // If it looks like a repo pattern (has slash), search for exact matches
    if (partial.includes('/')) {
      return await this.searchProjects(partial);
    }

    // If it's just an owner name, find all repos for that owner
    const projects = await this.listProjects();
    const ownerMatches = projects.filter(project => {
      const owner = project.name.split('/')[0];
      return owner.toLowerCase().startsWith(partial.toLowerCase());
    });

    return ownerMatches.map(p => p.name).sort();
  }
}

// CLI Interface
function printUsage() {
  console.log(`
Project Manager - A tool for managing GitHub projects locally

Usage:
  pm <owner/repo>        Get or clone a project
  pm list                List all projects
  pm update              Update all projects (git pull)
  pm clean               Show projects for manual cleanup
  pm cache-refresh       Clear completion cache (force rebuild)
  pm debug-completion    Show completion cache diagnostics
  pm complete <partial>  Get completion suggestions (for shell integration)
  pm help                Show this help

Examples:
  pm attamusc/dotfiles   # Clone or navigate to attamusc/dotfiles
  pm list                # List all local projects
  pm update              # Pull latest changes for all projects
  pm cache-refresh       # Clear completion cache if it seems stale
  pm debug-completion    # Debug tab completion issues

Shell Integration:
Add this function to your shell rc file (.bashrc, .zshrc, etc.):

function pm() {
  if [ "$1" = "help" ] || [ "$1" = "list" ] || [ "$1" = "update" ] || [ "$1" = "clean" ]; then
    node /path/to/this/script "$@"
  else
    local result=$(node /path/to/this/script "$@")
    if [ $? -eq 0 ] && [ -d "$result" ]; then
      cd "$result"
    fi
  fi
}

Tab Completion Cache:
- Tab completions are cached for 30 minutes for performance
- Cache is automatically rebuilt when stale or after cloning projects
- Use 'pm cache-refresh' to manually clear the cache
- Use 'pm debug-completion' to troubleshoot completion issues
`);
}

async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0 || args[0] === 'help') {
    printUsage();
    return;
  }

  const pm = new ProjectManager();
  const command = args[0];

  switch (command) {
    case 'list':
      const projects = await pm.listProjects();
      console.log('\nLocal Projects:');
      projects.forEach(project => {
        console.log(`  ${project.name} → ${project.path}`);
      });
      break;

    case 'update':
      await pm.updateProjects();
      break;

    case 'clean':
      await pm.cleanProjects();
      break;

    case 'cache-refresh':
      pm.invalidateCompletionCache();
      console.log('✓ Completion cache cleared');
      console.log('  Cache will be rebuilt on next tab completion');
      break;

    case 'debug-completion':
      await pm.debugCompletion();
      break;

    case 'complete':
      const partial = args[1] || '';
      const completions = await pm.getCompletions(partial);
      completions.forEach(completion => console.log(completion));
      break;

    default:
      // Assume it's a repo name
      await pm.getProject(command);
      break;
  }
}

if (require.main === module) {
  main().catch(error => {
    console.error('Unexpected error:', error);
    process.exit(1);
  });
}

module.exports = ProjectManager;
